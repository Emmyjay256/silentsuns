<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Silent Planets — TESS Orbit Viz</title>
  <style>
    :root{ --bg:#0b0b0b; --ink:#fff; --muted:#cfd3dc; --card:#111318; --glass:rgba(0,0,0,.55); --accent:#00e5ff; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Inter,Arial}
    a{color:#9cf}
    .wrap{max-width:1100px;margin:0 auto;padding:28px 16px 64px}
    h1{font-size:38px;line-height:1.1;margin:0 0 8px}
    .lead{color:var(--muted);margin:0 0 20px}

    .badge{display:inline-flex;gap:8px;align-items:center;background:#0f1420;border:1px solid #222938;color:#cfe2ff;border-radius:999px;padding:6px 10px;font-size:12px;margin-right:8px}
    .badge .dot{width:8px;height:8px;border-radius:999px;background:var(--accent);box-shadow:0 0 10px rgba(0,229,255,.5)}

    .card{background:var(--card);border:1px solid #1a1d24;border-radius:16px;box-shadow:0 6px 24px rgba(0,0,0,.35);overflow:hidden}
    .card + .card{ margin-top:18px; }
    .card-head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #1a1d24;background:#0e1016}
    .card-head h2{margin:0;font-size:16px;font-weight:700}
    .card-head .right{display:flex;gap:8px;align-items:center}
    .btn{appearance:none;border:1px solid #2a2e3a;background:#131721;color:#eaf6ff;cursor:pointer;padding:8px 12px;border-radius:10px;font-weight:700;font-size:12px;letter-spacing:.3px}
    .btn:hover{background:#0f1420}
    .hint{font-size:12px;color:#9fb0c8}

    .sim-panel{position:relative;width:100%;height:60vh;min-height:380px;background:#0a0c11}
    .overlay{position:absolute;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center}
    .panel{margin-top:14px;background:var(--glass);backdrop-filter:saturate(140%) blur(6px);border-radius:10px;padding:10px 12px;font-size:12px;line-height:1.4;max-width:520px}
    .bar{height:4px;background:rgba(255,255,255,.15);border-radius:2px;overflow:hidden;margin-top:6px}
    .fill{height:100%;width:0%;background:linear-gradient(90deg,#9cf,#9f9);transition:width .15s ease}
    .small{opacity:.85;font-size:11px;color:#ddd}
    .kbd{background:#222;border:1px solid #333;border-radius:4px;padding:1px 4px}

    #daysHUD{position:absolute;top:12px;right:12px;pointer-events:none;z-index:2;text-align:right}
    #daysHUD .title{font-weight:700;font-size:12px;letter-spacing:.6px;text-transform:uppercase;color:#a9cfe0}
    #daysHUD .value{margin-top:2px;font-weight:900;font-size:32px;line-height:1;color:var(--accent);text-shadow:0 0 10px rgba(0,229,255,.35)}

    .sim-panel canvas{position:absolute;inset:0;z-index:0;display:block;filter:blur(10px)}
    .sim-panel .css2d{position:absolute;inset:0;pointer-events:none;z-index:1}
    #hud{ z-index:3; }

    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-top:18px}
    .note{background:#0e1016;border:1px solid #1a1d24;border-radius:12px;padding:14px;color:#cfe2ff}

    /* NEW: content sections */
    .two-col{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media (max-width: 980px){ .two-col{grid-template-columns:1fr} }
    .section{margin-top:22px}
    .section h3{margin:0 0 10px;font-size:18px}
    .list{margin:0;padding-left:18px;color:#cfe2ff}
    .kpi{display:grid;grid-template-columns:repeat(4,minmax(120px,1fr));gap:12px}
    @media (max-width: 700px){ .kpi{grid-template-columns:repeat(2,1fr)} }
    .kpi .box{background:#0e1016;border:1px solid #1a1d24;border-radius:12px;padding:12px}
    .kpi .n{font-weight:800;font-size:22px;line-height:1;color:var(--accent)}
    .kpi .l{font-size:12px;color:#9fb0c8;margin-top:4px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:#cfe2ff}
    .small-muted{font-size:12px;color:#98a7bd}
    .pill{display:inline-block;background:#122033;border:1px solid #20324b;border-radius:999px;padding:6px 10px;font-size:12px;margin:0 8px 8px 0}
    .hr{height:1px;background:#1a1d24;margin:16px 0}
  </style>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
</head>
<body>
  <div class="wrap">
    <h1>Silent Planets</h1>
    <p class="lead">AI-powered exoplanet detection from raw FITS. Upload a light curve, get a physics-aware analysis, a 3D orbit, and an Earth visibility map.</p>
    <div>
      <span class="badge"><span class="dot"></span> NASA Space Apps — Prototype</span>
      <span class="badge">Kepler &amp; TESS ready</span>
      <span class="badge">Phase-fold + BLS + Detrend</span>
    </div>

    <!-- ====== NEW: Overview + Actions ====== -->
    <div class="card section">
      <div class="card-head">
        <h2>Project Overview</h2>
        <div class="right">
          <button class="btn" type="button" id="uploadBtn">Upload FITS</button>
          <a class="btn" href="#how" style="text-decoration:none">How it works</a>
        </div>
      </div>
      <div class="two-col" style="padding:14px;">
        <div class="note" style="background:transparent;border:none;padding:0">
          <h3>What we built</h3>
          <p>Silent Planets is an end-to-end pipeline and web UI: we ingest <span class="mono">.fits</span>, clean and detrend, run BLS to find periodic dips, phase-fold the curve, extract features, and pass them to a lightweight classifier. Results are rendered as an interactive orbit plus an Earth map for “where to look next”.</p>
          <div class="hr"></div>
          <div class="kpi">
            <div class="box"><div class="n" id="kpiSamples">—</div><div class="l">Processed samples</div></div>
            <div class="box"><div class="n" id="kpiPos">—</div><div class="l">Confirmed (train)</div></div>
            <div class="box"><div class="n" id="kpiNeg">—</div><div class="l">False positives (train)</div></div>
            <div class="box"><div class="n" id="kpiLatency">~2–4m</div><div class="l">Typical processing per FITS</div></div>
          </div>
          <p class="small-muted" style="margin-top:8px">KPIs auto-wire once the backend publishes dataset index counts.</p>
        </div>

        <div class="note">
          <h3>Quick actions</h3>
          <p><b>1)</b> <a href="#upload" id="uploadLink">Upload a FITS</a> (Kepler/TESS) — we’ll process on the backend and notify when ready.</p>
          <p><b>2)</b> Try the live orbit sim below (placeholder values). Hook it to your job payload when ready.</p>
          <div class="pill">Phase-folded curve</div>
          <div class="pill">BLS period &amp; t0</div>
          <div class="pill">Transit depth &amp; SNR</div>
          <div class="pill">20s / 2m cadence aware</div>
        </div>
      </div>
    </div>

    <!-- =============== ORBIT SIM =============== -->
    <div class="card">
      <div class="card-head">
        <h2>Orbit Simulation</h2>
        <div class="right">
          <span class="hint">Controls: <span class="kbd">[</span> slower, <span class="kbd">]</span> faster, <span class="kbd">Space</span> pause</span>
          <button id="fsBtn" class="btn" type="button">Enter Fullscreen</button>
        </div>
      </div>

      <div id="sim" class="sim-panel">
        <div class="overlay" id="hud">
          <div class="panel">
            <div><b>Loading scene…</b> <span id="pct">0%</span></div>
            <div class="small" id="small">Preparing lights &amp; placeholders…</div>
            <div class="bar"><div class="fill" id="fill"></div></div>
          </div>
        </div>

        <div id="daysHUD">
          <div class="title">Elapsed earth days</div>
          <div class="value" id="daysText">0 days</div>
        </div>
      </div>
    </div>

    <!-- ====== NEW: How it works ====== -->
    <div id="how" class="card section">
      <div class="card-head"><h2>How it works</h2></div>
      <div class="grid" style="padding:14px">
        <div class="note">
          <h3>1) Ingest &amp; standardize</h3>
          <ul class="list">
            <li>Read Kepler/TESS light-curve FITS</li>
            <li>Unify columns → <span class="mono">time, flux, flux_err, quality</span></li>
            <li>Remove NaNs and bad quality flags</li>
          </ul>
        </div>
        <div class="note">
          <h3>2) Detrend</h3>
          <ul class="list">
            <li>Savitzky–Golay smoothing</li>
            <li>Divide out long-term trends</li>
            <li>Normalize near 1.0</li>
          </ul>
        </div>
        <div class="note">
          <h3>3) BLS &amp; fold</h3>
          <ul class="list">
            <li>Box Least Squares over safe grids</li>
            <li>Pick best period, epoch, duration</li>
            <li>Phase-fold curve for model</li>
          </ul>
        </div>
        <div class="note">
          <h3>4) Classify &amp; visualize</h3>
          <ul class="list">
            <li>Lightweight 1D CNN + features</li>
            <li>Orbit viz with period/t0</li>
            <li>Earth visibility pinning</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- =============== EARTH VIEWER =============== -->
    <div class="card">
      <div class="card-head">
        <h2>Earth Viewer</h2>
        <div class="right">
          <span class="hint">GLB: <code>earth.glb</code></span>
          <button id="earthFsBtn" class="btn" type="button">Enter Fullscreen</button>
        </div>
      </div>
      <div id="earthPanel" class="sim-panel">
        <div class="overlay" id="earthHud">
          <div class="panel">
            <div><b>Loading Earth…</b> <span id="earthPct">0%</span></div>
            <div class="small" id="earthSmall">Setting up lights &amp; controls…</div>
            <div class="bar"><div class="fill" id="earthFill"></div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ====== NEW: Model status & recent runs ====== -->
    <div class="grid section">
      <div class="note">
        <h3>Model status</h3>
        <p class="small-muted">Live metrics wire into these placeholders when the backend publishes <span class="mono">dataset/index/*.csv</span> and a training summary.</p>
        <ul class="list">
          <li>Training samples: <span id="trainCount" class="mono">—</span></li>
          <li>Validation samples: <span id="valCount" class="mono">—</span></li>
          <li>Current F1 / AUC: <span id="f1auc" class="mono">—</span></li>
          <li>Last trained: <span id="lastTrained" class="mono">—</span></li>
        </ul>
      </div>
      <div class="note">
        <h3>Recent uploads</h3>
        <p class="small-muted">Show last 5 processed jobs with links to CSV, JSON, and phase plot.</p>
        <div id="recentList" class="small-muted">No jobs yet.</div>
      </div>
    </div>

    <!-- ====== NEW: FAQ ====== -->
    <div class="card section">
      <div class="card-head"><h2>FAQ</h2></div>
      <div style="padding:14px">
        <p><b>How long does a run take?</b> Typical FITS finish in ~2–4 minutes end-to-end (I/O + BLS dominate).</p>
        <p><b>What missions are supported?</b> Kepler (KIC) and TESS (TIC) light-curves; cadence-aware (20s &amp; 2m).</p>
        <p><b>What do I need to upload?</b> A single light-curve FITS per run. We parse headers for IDs automatically.</p>
      </div>
    </div>
  </div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
  import { CSS2DRenderer } from 'https://unpkg.com/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

  // ---- small UX bits (upload stub + KPI placeholders) ----
  document.getElementById('uploadBtn')?.addEventListener('click', ()=>{
    // Replace with your signed-URL flow
    alert('Upload flow coming soon: we will request a signed URL, PUT the FITS, and show job status.');
  });
  document.getElementById('uploadLink')?.addEventListener('click', (e)=>{ e.preventDefault(); document.getElementById('uploadBtn').click(); });

  // Optional: hydrate KPIs from a JSON endpoint later
  const fallbackKPIs = { samples:'—', pos:'—', neg:'—' };
  const setText = (id, val)=>{ const el=document.getElementById(id); if(el) el.textContent = val; };
  setText('kpiSamples', fallbackKPIs.samples);
  setText('kpiPos', fallbackKPIs.pos);
  setText('kpiNeg', fallbackKPIs.neg);

  /* ====================== ORBIT SIM (unchanged core) ====================== */
  const received = { tic:261136679, spectral_type:"A", period_days:5.4321, t0_btjd:134.5342, semi_major_axis_scene:1.4, planet_radius_scene:0.25, star_radius_scene:0.7 };
  const MIN_ORBIT_MULT = 8;
  if (received.semi_major_axis_scene < MIN_ORBIT_MULT * received.star_radius_scene) {
    received.semi_major_axis_scene = MIN_ORBIT_MULT * received.star_radius_scene;
  }
  let SIM_SPEED_DAYS_PER_SEC = 1.0;
  let paused = false;

  const simPanel = document.getElementById('sim');
  const fsBtn = document.getElementById('fsBtn');
  const pctEl = document.getElementById('pct');
  const fillEl = document.getElementById('fill');
  const smallEl = document.getElementById('small');
  const daysText = document.getElementById('daysText');
  const setProgress = (p)=>{ const v=Math.max(0,Math.min(100,p)); pctEl.textContent = v.toFixed(0)+'%'; fillEl.style.width = v+'%'; };

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0b);

  const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
  camera.position.set(0, 1.2, 3.2);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  simPanel.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.inset = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  labelRenderer.domElement.classList.add('css2d');
  simPanel.appendChild(labelRenderer.domElement);

  function sizeToPanel(){
    const w = simPanel.clientWidth, h = simPanel.clientHeight;
    camera.aspect = w / h; camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
    labelRenderer.setSize(w, h);
  }
  sizeToPanel();

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const key   = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set( 5, 5,  5);
  const fill  = new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-5, 2,  5);
  const back  = new THREE.DirectionalLight(0xffffff, 0.75); back.position.set( 0, 5, -6);
  const amb   = new THREE.AmbientLight(0xffffff, 0.2);
  scene.add(key, fill, back, amb);

  const placeholderStarMat = new THREE.MeshStandardMaterial({
    color: 0xffcc66, emissive: 0xffaa33, emissiveIntensity: 0.6, roughness: 0.6, metalness: 0.0
  });
  const starPH = new THREE.Mesh(new THREE.SphereGeometry(received.star_radius_scene, 48, 24), placeholderStarMat);
  scene.add(starPH);

  const planetPH = new THREE.Mesh(
    new THREE.SphereGeometry(received.planet_radius_scene, 36, 18),
    new THREE.MeshStandardMaterial({ color: 0xffe199, emissive: 0xffcc66, emissiveIntensity: 0.7, roughness: 0.5 })
  );
  planetPH.position.set(received.semi_major_axis_scene, 0, 0);
  scene.add(planetPH);

  function sunPathForSpectral(s) {
    const t = (s || '').toUpperCase();
    if (t.startsWith('K') || t.startsWith('M')) return './red.glb';
    if (t.startsWith('G') || t.startsWith('F')) return './yellow.glb';
    return './blue.glb';
  }

  const manager = new THREE.LoadingManager();
  manager.onProgress = (_u, loaded, total)=>{ const p=total?(loaded/total)*100:50; setProgress(p); applyBlur(10*(1-p/100)); };
  manager.onLoad = ()=> setProgress(100);

  let currentBlur = 10;
  function applyBlur(px){ renderer.domElement.style.filter = `blur(${px}px)`; }

  const loader = new GLTFLoader(manager);
  let starReal = null, planetReal = null, reveal = 0;

  loader.load(sunPathForSpectral(received.spectral_type), (gltf)=>{
    starReal = gltf.scene;
    starReal.scale.setScalar(received.star_radius_scene);
    starReal.traverse(o=>{ if (o.isMesh && o.material){ o.material = o.material.clone(); o.material.transparent = true; o.material.opacity = 0; }});
    scene.add(starReal);
    smallEl.textContent = 'Sun model loaded…';
    reveal = Math.max(reveal, 0.001);
  });

  loader.load('./planet.glb', (gltf)=>{
    planetReal = gltf.scene;
    planetReal.scale.setScalar(received.planet_radius_scene);
    planetReal.position.copy(planetPH.position);
    planetReal.traverse(o=>{ if (o.isMesh && o.material){ o.material = o.material.clone(); o.material.transparent = true; o.material.opacity = 0; }});
    scene.add(planetReal);
    smallEl.textContent = 'Planet model loaded…';
    reveal = Math.max(reveal, 0.001);
  });

  const TUBE_COLOR = 0x00e5ff;
  const tubeMaterial = new THREE.MeshBasicMaterial({ color: TUBE_COLOR, transparent: true, opacity: 0.95 });
  let progressMesh = null, arcStartTheta = null, lastTheta = null, orbitStartSimDays = 0;

  function updateProgressArc(R, startTheta, endTheta) {
    const delta = endTheta - startTheta;
    const steps = Math.max(8, Math.ceil(128 * (delta / (Math.PI * 2))));
    const pts = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const th = startTheta + t * delta;
      pts.push(new THREE.Vector3(Math.cos(th) * R, 0, Math.sin(th) * R));
    }
    const curve = new THREE.CatmullRomCurve3(pts, false, 'catmullrom', 0.0);
    const tubularSegments = Math.max(24, steps * 3);
    const tubeRadius = Math.max(0.01, received.planet_radius_scene * 0.22);
    const geom = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, 6, false);
    if (!progressMesh) { progressMesh = new THREE.Mesh(geom, tubeMaterial); progressMesh.renderOrder = 2; scene.add(progressMesh); }
    else { progressMesh.geometry.dispose(); progressMesh.geometry = geom; }
  }

  let simDays = 0, lastT = performance.now();
  function stepSim(nowMs){ const dt=(nowMs-lastT)/1000; lastT=nowMs; if(!paused) simDays += dt * SIM_SPEED_DAYS_PER_SEC; }
  const PI2 = Math.PI * 2;
  function orbitAngle(period_days, t0_btjd, current_btjd){
    const ph = ((current_btjd - t0_btjd) / period_days) % 1; return (ph < 0 ? ph + 1 : ph) * PI2;
  }
  const currentBTJD = ()=> received.t0_btjd + simDays;

  function animateOrbit(tMs){
    requestAnimationFrame(animateOrbit);
    stepSim(tMs);
    placeholderStarMat.emissiveIntensity = 0.6 + Math.sin(tMs*0.0012)*0.04;
    starPH.rotation.y += 0.001; if (starReal) starReal.rotation.y += 0.001;
    planetPH.rotation.y += 0.008; if (planetReal) planetReal.rotation.y += 0.01;

    const R = received.semi_major_axis_scene;
    const theta = orbitAngle(received.period_days, received.t0_btjd, currentBTJD());
    const x = Math.cos(theta) * R, z = Math.sin(theta) * R;
    planetPH.position.set(x, 0, z); if (planetReal) planetReal.position.set(x, 0, z);

    if (arcStartTheta === null) {
      arcStartTheta = theta; lastTheta = theta; orbitStartSimDays = simDays;
      updateProgressArc(R, arcStartTheta, theta + 1e-6);
    } else {
      if (theta < lastTheta) { arcStartTheta = theta; orbitStartSimDays = simDays; updateProgressArc(R, arcStartTheta, theta + 1e-6); }
      else { updateProgressArc(R, arcStartTheta, theta); }
      lastTheta = theta;
    }
    const orbitElapsed = simDays - orbitStartSimDays;
    daysText.textContent = `${Math.floor(orbitElapsed)} days`;

    if (reveal > 0 && starReal && planetReal){
      reveal = Math.min(1, reveal + 0.03);
      const realOpacity = reveal;
      starReal.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });
      planetReal.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });
      starPH.visible = (1 - reveal) > 0.02; planetPH.visible = (1 - reveal) > 0.02;
      currentBlur = Math.max(0, currentBlur - 0.6); applyBlur(currentBlur);
      if (reveal === 1){ document.getElementById('hud').style.display='none'; applyBlur(0); }
    }

    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  applyBlur(currentBlur);
  animateOrbit(0);

  addEventListener('resize', sizeToPanel);
  document.addEventListener('fullscreenchange', sizeToPanel);
  fsBtn.addEventListener('click', async ()=>{
    if (!document.fullscreenElement){ await simPanel.requestFullscreen(); fsBtn.textContent='Exit Fullscreen'; }
    else { await document.exitFullscreen(); fsBtn.textContent='Enter Fullscreen'; }
    sizeToPanel();
  });

  addEventListener('keydown', (e)=>{
    if (e.key === '[') { SIM_SPEED_DAYS_PER_SEC = Math.max(0.01, SIM_SPEED_DAYS_PER_SEC / 1.5); smallEl.textContent = `Speed: ${SIM_SPEED_DAYS_PER_SEC.toFixed(2)} d/s (slower)`; }
    else if (e.key === ']') { SIM_SPEED_DAYS_PER_SEC = Math.min(1e3, SIM_SPEED_DAYS_PER_SEC * 1.5); smallEl.textContent = `Speed: ${SIM_SPEED_DAYS_PER_SEC.toFixed(2)} d/s (faster)`; }
    else if (e.code === 'Space') { paused = !paused; smallEl.textContent = paused ? 'Paused' : `Speed: ${SIM_SPEED_DAYS_PER_SEC.toFixed(2)} d/s`; }
  });
  setProgress(5);

  /* ====================== EARTH VIEWER (unchanged core) ====================== */
  (function initEarthViewer(){
    const panel   = document.getElementById('earthPanel');
    const fsBtn   = document.getElementById('earthFsBtn');
    const pctEl   = document.getElementById('earthPct');
    const fillEl  = document.getElementById('earthFill');
    const smallEl = document.getElementById('earthSmall');

    function setEarthProgress(p){
      const v = Math.max(0, Math.min(100, p));
      pctEl.textContent = v.toFixed(0) + '%';
      fillEl.style.width = v + '%';
    }
    function sizeEarthToPanel(camera, renderer){
      const w = panel.clientWidth, h = panel.clientHeight;
      camera.aspect = w / h; camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
    camera.position.set(0, 0.8, 2.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else renderer.outputEncoding = THREE.sRGBEncoding;
    panel.appendChild(renderer.domElement);
    sizeEarthToPanel(camera, renderer);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const amb  = new THREE.AmbientLight(0xffffff, 0.35);
    const key  = new THREE.DirectionalLight(0xffffff, 1.1); key.position.set( 5, 4,  6);
    const rim  = new THREE.DirectionalLight(0x99b7ff, 0.6); rim.position.set(-6, 2, -4);
    const hemi = new THREE.HemisphereLight(0x668cff, 0x0a0c11, 0.3);
    scene.add(amb, key, rim, hemi);

    function applyEarthBlur(px){ renderer.domElement.style.filter = `blur(${px}px)`; }
    let blur = 10; applyEarthBlur(blur);

    const manager = new THREE.LoadingManager();
    manager.onProgress = (_url, loaded, total)=>{ const p = total ? (loaded/total)*100 : 50; setEarthProgress(p); blur = 10 * (1 - p/100); applyEarthBlur(blur); };
    manager.onLoad = ()=>{ setEarthProgress(100); applyEarthBlur(0); document.getElementById('earthHud').style.display = 'none'; };

    const loader = new GLTFLoader(manager);
    let earth = null, earthCore = null;

    // Shared pin assets (single color)
    const PIN_MAT = new THREE.MeshBasicMaterial({ color: 0x00e5ff });
    const PIN_CONE = new THREE.ConeGeometry(0.03, 0.12, 16);
    const PIN_RING = new THREE.TorusGeometry(0.045, 0.008, 8, 24);
    PIN_MAT.polygonOffset = true; PIN_MAT.polygonOffsetFactor = -1; PIN_MAT.polygonOffsetUnits = -1;

    let activePins = [];
    function createPin(){
      const g = new THREE.Group();
      const cone = new THREE.Mesh(PIN_CONE, PIN_MAT);
      const ring = new THREE.Mesh(PIN_RING, PIN_MAT);
      cone.position.y = 0.06;
      ring.rotation.x = Math.PI/2;
      g.add(cone, ring);
      return g;
    }

    function getEarthRadiusLocal(){ return 1.0; }

    // Africa calibration + orientation helpers
    function toGlobe(lat, lon) {
      return { lat: lat - 7, lon: ((lon + 80 + 180) % 360) - 180 };
    }
    function latLonToLocal(latDeg, lonDeg, rLocal) {
      const lat = THREE.MathUtils.degToRad(latDeg);
      const lon = THREE.MathUtils.degToRad(-lonDeg);
      const dir = new THREE.Vector3(
        Math.cos(lat) * Math.cos(lon),
        Math.sin(lat),
        Math.cos(lat) * Math.sin(lon)
      ).normalize();
      return dir.multiplyScalar(rLocal);
    }

    function placeRegionPins(regions){
      if (!earth) return;
      for (const p of activePins) earth.remove(p);
      activePins = [];

      const r = getEarthRadiusLocal();
      for (const bundle of regions){
        for (const {lat, lon} of bundle){
          const g = toGlobe(lat, lon);
          const pos = latLonToLocal(g.lat, g.lon, r);
          const pin = createPin();
          pin.position.copy(pos);
          pin.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), pos.clone().normalize());
          earth.add(pin);
          activePins.push(pin);
        }
      }
    }
    window.placeRegionPins = placeRegionPins;

    loader.load('./earth.glb', (gltf)=>{
      earth = gltf.scene;
      earth.traverse(o=>{
        if (o.isMesh) {
          o.material = o.material.clone();
          if (!earthCore) earthCore = o;
          else{
            const a = earthCore.geometry?.boundingSphere?.radius || 0;
            const b = o.geometry?.boundingSphere?.radius || 0;
            if (b > a) earthCore = o;
          }
        }
      });
      if (earthCore && !earthCore.geometry.boundingSphere) earthCore.geometry.computeBoundingSphere();
      scene.add(earth);

      // Demo pins
      placeRegionPins([
        [ {lat:-1, lon:33}, {lat:0, lon:32.7}, {lat:1, lon:33.2} ],
        [ {lat:30.044, lon:31.235}, {lat:29.95, lon:31.4} ]
      ]);
    }, undefined, (err)=> smallEl.textContent = 'Load error: ' + (err?.message || err));

    function animate(){
      requestAnimationFrame(animate);
      if (earth) earth.rotation.y += 0.0018;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    const onResize = ()=> sizeEarthToPanel(camera, renderer);
    addEventListener('resize', onResize);
    document.addEventListener('fullscreenchange', onResize);
    fsBtn.addEventListener('click', async ()=>{
      if (!document.fullscreenElement){ await panel.requestFullscreen(); fsBtn.textContent='Exit Fullscreen'; }
      else { await document.exitFullscreen(); fsBtn.textContent='Enter Fullscreen'; }
      sizeEarthToPanel(camera, renderer);
    });
  })();
</script>
</body>
</html>
