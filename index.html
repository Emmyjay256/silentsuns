<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TESS Orbit Viz — Sun Selector + Planet Orbit</title>
  <style>
    html,body{height:100%}
    body{margin:0;overflow:hidden;background:#0b0b0b;color:#fff;font-family:system-ui}

    /* HUD */
    #hud{position:absolute;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center}
    #panel{margin-top:14px;background:rgba(0,0,0,.55);backdrop-filter:saturate(140%) blur(6px);
           border-radius:10px;padding:10px 12px;font-size:12px;line-height:1.4;max-width:420px}
    #bar{height:4px;background:rgba(255,255,255,.15);border-radius:2px;overflow:hidden;margin-top:6px}
    #fill{height:100%;width:0%;background:linear-gradient(90deg,#9cf,#9f9);transition:width .15s ease}
    #small{opacity:.85;font-size:11px;color:#ddd}

    /* canvas blur dialed down as we load */
    canvas{display:block;filter:blur(10px)}
    .hidden{display:none}

    /* CSS2D label */
    .label{
      padding:4px 6px;border-radius:6px;background:rgba(0,0,0,.55);
      font:600 12px/1.2 system-ui, sans-serif;color:#fff;pointer-events:none;
      transform:translate(-50%,-120%);white-space:nowrap
    }
  </style>

  <!-- Import map so "three" works in-browser -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="hud">
  <div id="panel">
    <div><b>Loading scene…</b> <span id="pct">0%</span></div>
    <div id="small">Preparing lights & placeholders…</div>
    <div id="bar"><div id="fill"></div></div>
  </div>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
  import { CSS2DRenderer, CSS2DObject } from 'https://unpkg.com/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

  // -----------------------
  // HARD-CODED RECEIVED DATA (replace with backend payload later)
  // -----------------------
  const received = {
    tic: 261136679,
    spectral_type: "K",          // one of: K/M -> red.glb, G/F -> yellow.glb, A/B -> blue.glb
    period_days: 5.4321,         // orbital period
    t0_btjd: 134.5342,           // mid-transit reference (BTJD)
    semi_major_axis_scene: 1.4,  // orbit radius in scene units
    planet_radius_scene: 0.25,   // how big to draw the planet (scene units)
    star_radius_scene: 0.7       // how big to draw the star (scene units)
  };

  // Simulation: how many *Earth days* advance per real second (visualization speed)
  const SIM_SPEED_DAYS_PER_SEC = 8;

  // -----------------------
  // UI helpers
  // -----------------------
  const pctEl = document.getElementById('pct');
  const fillEl = document.getElementById('fill');
  const smallEl = document.getElementById('small');
  const panelEl = document.getElementById('panel');
  const setProgress = (p)=>{ const v=Math.max(0,Math.min(100,p)); pctEl.textContent = v.toFixed(0)+'%'; fillEl.style.width = v+'%'; };

  // -----------------------
  // Scene / camera / renderers
  // -----------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0b);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 1.2, 3.2);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.inset = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  document.body.appendChild(labelRenderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // -----------------------
  // Lights
  // -----------------------
  const key   = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set( 5, 5,  5);
  const fill  = new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-5, 2,  5);
  const back  = new THREE.DirectionalLight(0xffffff, 0.75); back.position.set( 0, 5, -6);
  const amb   = new THREE.AmbientLight(0xffffff, 0.2);
  scene.add(key, fill, back, amb);

  // -----------------------
  // Placeholders (show instantly while GLBs load)
  // -----------------------
  const placeholderStarMat = new THREE.MeshStandardMaterial({
    color: 0xffcc66, emissive: 0xffaa33, emissiveIntensity: 0.6, roughness: 0.6, metalness: 0.0
  });
  const starPH = new THREE.Mesh(new THREE.SphereGeometry(received.star_radius_scene, 48, 24), placeholderStarMat);
  starPH.name = 'starPH';
  scene.add(starPH);

  const planetPH = new THREE.Mesh(
    new THREE.SphereGeometry(received.planet_radius_scene, 36, 18),
    new THREE.MeshStandardMaterial({ color: 0xffe199, emissive: 0xffcc66, emissiveIntensity: 0.7, roughness: 0.5 })
  );
  planetPH.position.set(received.semi_major_axis_scene, 0, 0);
  planetPH.name = 'planetPH';
  scene.add(planetPH);

  // Label that follows the planet (elapsed Earth days)
  const lbl = document.createElement('div');
  lbl.className = 'label';
  lbl.textContent = '0.0 d';
  const lblObj = new CSS2DObject(lbl);
  lblObj.position.set(0, received.planet_radius_scene * 0.9, 0);
  planetPH.add(lblObj);

  smallEl.textContent = 'Placeholders visible… loading GLB models';

  // -----------------------
  // Choose sun model by spectral type
  // -----------------------
  function sunPathForSpectral(s) {
    const t = (s || '').toUpperCase();
    if (t.startsWith('K') || t.startsWith('M')) return './red.glb';
    if (t.startsWith('G') || t.startsWith('F')) return './yellow.glb';
    // default hot bucket for A/B (and anything unknown)
    return './blue.glb';
  }

  // -----------------------
  // Loading manager (aggregate progress of both GLBs)
  // -----------------------
  const manager = new THREE.LoadingManager();
  manager.onProgress = (url, loaded, total) => {
    const p = total ? (loaded/total)*100 : 50;
    setProgress(p);
    applyBlur(10 * (1 - p/100));
  };
  manager.onLoad = () => {
    setProgress(100);
    // blur will be eased to 0 in the reveal loop
  };

  const loader = new GLTFLoader(manager);

  // Canvas blur control
  let currentBlur = 10;
  function applyBlur(px){ renderer.domElement.style.filter = `blur(${px}px)`; }

  // -----------------------
  // Load GLBs
  // -----------------------
  let starReal = null;
  let planetReal = null;
  let reveal = 0; // 0..1

  // Star
  loader.load(
    sunPathForSpectral(received.spectral_type),
    (gltf)=>{
      starReal = gltf.scene;
      starReal.scale.setScalar(received.star_radius_scene / 0.5); // normalize if model radius ≈0.5; adjust if needed
      starReal.traverse(o=>{
        if (o.isMesh && o.material){
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0;
          o.castShadow = false; o.receiveShadow = false;
        }
      });
      scene.add(starReal);
      smallEl.textContent = 'Sun model loaded…';
      reveal = Math.max(reveal, 0.001);
    },
    undefined,
    (err)=> smallEl.textContent = 'Sun load error: '+(err?.message||err)
  );

  // Planet
  loader.load(
    './planet.glb',
    (gltf)=>{
      planetReal = gltf.scene;
      planetReal.scale.setScalar(received.planet_radius_scene); // assume unit sphere inside the GLB
      planetReal.position.copy(planetPH.position);
      planetReal.traverse(o=>{
        if (o.isMesh && o.material){
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0;
          o.castShadow = false; o.receiveShadow = false;
        }
      });
      scene.add(planetReal);

      // Move label from placeholder to the real planet
      if (lblObj.parent) lblObj.parent.remove(lblObj);
      planetReal.add(lblObj);
      lblObj.position.set(0, received.planet_radius_scene * 0.9, 0);

      smallEl.textContent = 'Planet model loaded…';
      reveal = Math.max(reveal, 0.001);
    },
    undefined,
    (err)=> smallEl.textContent = 'Planet load error: '+(err?.message||err)
  );

  // -----------------------
  // Simulation time + orbit helpers
  // -----------------------
  let simDays = 0;
  let lastT = performance.now();

  function stepSim(nowMs){
    const dt = (nowMs - lastT) / 1000;
    lastT = nowMs;
    simDays += dt * SIM_SPEED_DAYS_PER_SEC;
  }

  function orbitAngle(period_days, t0_btjd, current_btjd){
    const ph = ((current_btjd - t0_btjd) / period_days) % 1;
    const phase = ph < 0 ? ph + 1 : ph;
    return phase * Math.PI * 2;
  }

  function currentBTJD(){ return received.t0_btjd + simDays; }

  // -----------------------
  // Animate
  // -----------------------
  function animate(tMs){
    requestAnimationFrame(animate);
    stepSim(tMs);

    const t = tMs * 0.001;

    // placeholder pulse
    const pulse = 0.6 + Math.sin(t*2.0)*0.08;
    placeholderStarMat.emissiveIntensity = pulse;

    // spins
    starPH.rotation.y   += 0.004;
    planetPH.rotation.y += 0.008;
    if (starReal)   starReal.rotation.y   += 0.005;
    if (planetReal) planetReal.rotation.y += 0.01;

    // orbit
    const R = received.semi_major_axis_scene;
    const ang = orbitAngle(received.period_days, received.t0_btjd, currentBTJD());
    const x = Math.cos(ang) * R;
    const z = Math.sin(ang) * R;
    const y = 0.0;
    planetPH.position.set(x, y, z);
    if (planetReal) planetReal.position.set(x, y, z);

    // label text
    lbl.textContent = `${simDays.toFixed(1)} d`;

    // crossfade placeholders -> real; finish blur-down
    if (reveal > 0 && starReal && planetReal){
      reveal = Math.min(1, reveal + 0.03);

      const realOpacity = reveal;
      starReal.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });
      planetReal.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });

      starPH.visible   = (1 - reveal) > 0.02;
      planetPH.visible = (1 - reveal) > 0.02;

      currentBlur = Math.max(0, currentBlur - 0.6);
      applyBlur(currentBlur);

      if (reveal === 1){
        panelEl.classList.add('hidden');
        applyBlur(0);
      }
    }

    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  applyBlur(currentBlur);
  animate(0);

  // -----------------------
  // Resize
  // -----------------------
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    labelRenderer.setSize(innerWidth, innerHeight);
  });

  // start progress non-zero so bar isn’t empty on cache
  setProgress(5);
</script>
</body>
</html>
