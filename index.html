<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TESS Orbit Viz — Progress Arc + Days Counter</title>
  <style>
    html,body{height:100%}
    body{margin:0;overflow:hidden;background:#0b0b0b;color:#fff;font-family:system-ui}

    /* HUD */
    #hud{position:absolute;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center}
    #panel{margin-top:14px;background:rgba(0,0,0,.55);backdrop-filter:saturate(140%) blur(6px);
           border-radius:10px;padding:10px 12px;font-size:12px;line-height:1.4;max-width:520px}
    #bar{height:4px;background:rgba(255,255,255,.15);border-radius:2px;overflow:hidden;margin-top:6px}
    #fill{height:100%;width:0%;background:linear-gradient(90deg,#9cf,#9f9);transition:width .15s ease}
    #small{opacity:.85;font-size:11px;color:#ddd}

    /* canvas blur dialed down as we load */
    canvas{display:block;filter:blur(10px)}
    .hidden{display:none}

    /* CSS2D label (above planet) */
    .label{
      padding:4px 6px;border-radius:6px;background:rgba(0,0,0,.55);
      font:600 12px/1.2 system-ui, sans-serif;color:#fff;pointer-events:none;
      transform:translate(-50%,-120%);white-space:nowrap
    }
    .kbd{background:#222;border:1px solid #333;border-radius:4px;padding:1px 4px}

    /* Big corner days counter (same color as tube) */
    #daysHUD{
      position:absolute;top:14px;right:16px;pointer-events:none;
      font-weight:800;font-size:28px;line-height:1;color:#00e5ff;
      text-shadow:0 0 10px rgba(0,229,255,.35);
    }
    #daysHUD small{font-weight:600;font-size:12px;opacity:.8;display:block}
  </style>

  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
</head>
<body>
<div id="hud">
  <div id="panel">
    <div><b>Loading scene…</b> <span id="pct">0%</span></div>
    <div id="small">
      Preparing lights & placeholders…<br>
      <span style="opacity:.9">Controls:</span>
      <span class="kbd">[</span> slower,
      <span class="kbd">]</span> faster,
      <span class="kbd">Space</span> pause
    </div>
    <div id="bar"><div id="fill"></div></div>
  </div>
</div>
<div id="daysHUD"><small>elapsed (per orbit)</small><span id="daysText">0.00 d</span></div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
  import { CSS2DRenderer, CSS2DObject } from 'https://unpkg.com/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

  // -----------------------
  // HARD-CODED RECEIVED DATA (replace with backend payload later)
  // -----------------------
  const received = {
    tic: 261136679,
    spectral_type: "K",          // K/M -> red.glb, G/F -> yellow.glb, A/B -> blue.glb
    period_days: 5.4321,         // orbital period
    t0_btjd: 134.5342,           // mid-transit reference (BTJD)
    semi_major_axis_scene: 1.4,  // orbit radius in scene units (will be clamped)
    planet_radius_scene: 0.25,   // planet size (scene units)
    star_radius_scene: 0.7       // star size (scene units)
  };

  // Enforce safe orbit spacing so it never intersects the star
  const MIN_ORBIT_MULT = 8;
  if (received.semi_major_axis_scene < MIN_ORBIT_MULT * received.star_radius_scene) {
    console.warn('[viz] Orbit too tight; expanding to avoid overlap.');
    received.semi_major_axis_scene = MIN_ORBIT_MULT * received.star_radius_scene;
  }

  // Simulation speed (Earth days per real second)
  let SIM_SPEED_DAYS_PER_SEC = 1.0;  // calm default
  let paused = false;

  // -----------------------
  // UI helpers
  // -----------------------
  const pctEl = document.getElementById('pct');
  const fillEl = document.getElementById('fill');
  const smallEl = document.getElementById('small');
  const panelEl = document.getElementById('panel');
  const daysText = document.getElementById('daysText');
  const setProgress = (p)=>{ const v=Math.max(0,Math.min(100,p)); pctEl.textContent = v.toFixed(0)+'%'; fillEl.style.width = v+'%'; };

  // -----------------------
  // Scene / camera / renderers
  // -----------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0b);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 1.2, 3.2);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.inset = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  document.body.appendChild(labelRenderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // -----------------------
  // Lights
  // -----------------------
  const key   = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set( 5, 5,  5);
  const fill  = new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-5, 2,  5);
  const back  = new THREE.DirectionalLight(0xffffff, 0.75); back.position.set( 0, 5, -6);
  const amb   = new THREE.AmbientLight(0xffffff, 0.2);
  scene.add(key, fill, back, amb);

  // -----------------------
  // Placeholders (instant)
  // -----------------------
  const placeholderStarMat = new THREE.MeshStandardMaterial({
    color: 0xffcc66, emissive: 0xffaa33, emissiveIntensity: 0.6, roughness: 0.6, metalness: 0.0
  });
  const starPH = new THREE.Mesh(new THREE.SphereGeometry(received.star_radius_scene, 48, 24), placeholderStarMat);
  starPH.name = 'starPH';
  scene.add(starPH);

  const planetPH = new THREE.Mesh(
    new THREE.SphereGeometry(received.planet_radius_scene, 36, 18),
    new THREE.MeshStandardMaterial({ color: 0xffe199, emissive: 0xffcc66, emissiveIntensity: 0.7, roughness: 0.5 })
  );
  planetPH.position.set(received.semi_major_axis_scene, 0, 0);
  planetPH.name = 'planetPH';
  scene.add(planetPH);

  // Label that follows the planet (ALWAYS above it → big offset)
  const lbl = document.createElement('div');
  lbl.className = 'label';
  lbl.textContent = '0.00 d';
  const lblObj = new CSS2DObject(lbl);
  lblObj.position.set(0, received.planet_radius_scene * 1.6, 0);
  planetPH.add(lblObj);

  smallEl.textContent = 'Placeholders visible… loading GLB models';

  // -----------------------
  // Choose sun model by spectral type
  // -----------------------
  function sunPathForSpectral(s) {
    const t = (s || '').toUpperCase();
    if (t.startsWith('K') || t.startsWith('M')) return './red.glb';
    if (t.startsWith('G') || t.startsWith('F')) return './yellow.glb';
    return './blue.glb'; // A/B/unknown
  }

  // -----------------------
  // Loading manager
  // -----------------------
  const manager = new THREE.LoadingManager();
  manager.onProgress = (url, loaded, total) => {
    const p = total ? (loaded/total)*100 : 50;
    setProgress(p);
    applyBlur(10 * (1 - p/100));
  };
  manager.onLoad = () => { setProgress(100); };

  const loader = new GLTFLoader(manager);

  // Canvas blur control
  let currentBlur = 10;
  function applyBlur(px){ renderer.domElement.style.filter = `blur(${px}px)`; }

  // -----------------------
  // Load GLBs
  // -----------------------
  let starReal = null;
  let planetReal = null;
  let reveal = 0; // 0..1

  // Star
  loader.load(
    sunPathForSpectral(received.spectral_type),
    (gltf)=>{
      starReal = gltf.scene;
      starReal.scale.setScalar(received.star_radius_scene);
      starReal.traverse(o=>{
        if (o.isMesh && o.material){
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0;
        }
      });
      scene.add(starReal);
      smallEl.textContent = 'Sun model loaded…';
      reveal = Math.max(reveal, 0.001);
    },
    undefined,
    (err)=> smallEl.textContent = 'Sun load error: '+(err?.message||err)
  );

  // Planet
  loader.load(
    './planet.glb',
    (gltf)=>{
      planetReal = gltf.scene;
      planetReal.scale.setScalar(received.planet_radius_scene);
      planetReal.position.copy(planetPH.position);
      planetReal.traverse(o=>{
        if (o.isMesh && o.material){
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0;
        }
      });
      scene.add(planetReal);

      // Move label from placeholder to the real planet (keep offset)
      if (lblObj.parent) lblObj.parent.remove(lblObj);
      planetReal.add(lblObj);
      lblObj.position.set(0, received.planet_radius_scene * 1.6, 0);

      smallEl.textContent = 'Planet model loaded…';
      reveal = Math.max(reveal, 0.001);
    },
    undefined,
    (err)=> smallEl.textContent = 'Planet load error: '+(err?.message||err)
  );

  // -----------------------
  // Progress Tube (growing orbital arc)
  // -----------------------
  // Tube color (match HUD)
  const TUBE_COLOR = 0x00e5ff;
  const tubeMaterial = new THREE.MeshBasicMaterial({ color: TUBE_COLOR, transparent: true, opacity: 0.95 });

  let progressMesh = null;
  let arcStartTheta = null;        // where current arc started (radians)
  let lastTheta = null;            // last angle to detect wrap
  let orbitStartSimDays = 0;       // simDays when this orbit started

  // Build/replace the arc geometry from start to end angle (in radians)
  function updateProgressArc(R, startTheta, endTheta) {
    // Ensure increasing; if end < start we reset externally (don’t draw across wrap)
    const delta = endTheta - startTheta;
    const steps = Math.max(8, Math.ceil(128 * (delta / (Math.PI * 2)))); // proportional detail
    const pts = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const th = startTheta + t * delta;
      pts.push(new THREE.Vector3(Math.cos(th) * R, 0, Math.sin(th) * R));
    }
    const curve = new THREE.CatmullRomCurve3(pts, false, 'catmullrom', 0.0);
    const tubularSegments = Math.max(24, steps * 3);
    const tubeRadius = Math.max(0.01, received.planet_radius_scene * 0.22); // thin, scale with planet size
    const radialSegments = 6;

    const geom = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, radialSegments, false);

    if (!progressMesh) {
      progressMesh = new THREE.Mesh(geom, tubeMaterial);
      progressMesh.renderOrder = 2; // draw on top if z-fighting
      scene.add(progressMesh);
    } else {
      progressMesh.geometry.dispose();
      progressMesh.geometry = geom;
    }
  }

  // -----------------------
  // Simulation time + orbit helpers
  // -----------------------
  let simDays = 0;
  let lastT = performance.now();

  function stepSim(nowMs){
    const dt = (nowMs - lastT) / 1000;
    lastT = nowMs;
    if (!paused) simDays += dt * SIM_SPEED_DAYS_PER_SEC;
  }

  function orbitAngle(period_days, t0_btjd, current_btjd){
    const ph = ((current_btjd - t0_btjd) / period_days) % 1;
    const phase = ph < 0 ? ph + 1 : ph;
    return phase * Math.PI * 2;
  }

  function currentBTJD(){ return received.t0_btjd + simDays; }

  // -----------------------
  // Animate
  // -----------------------
  function animate(tMs){
    requestAnimationFrame(animate);
    stepSim(tMs);

    const t = tMs * 0.001;

    // subtle star pulse + very slow spin
    placeholderStarMat.emissiveIntensity = 0.6 + Math.sin(t*1.2)*0.04;
    starPH.rotation.y += 0.001;
    if (starReal) starReal.rotation.y += 0.001;

    // planet self-rotation
    planetPH.rotation.y += 0.008;
    if (planetReal) planetReal.rotation.y += 0.01;

    // orbit (xz-plane)
    const R = received.semi_major_axis_scene;
    const theta = orbitAngle(received.period_days, received.t0_btjd, currentBTJD());
    const x = Math.cos(theta) * R;
    const z = Math.sin(theta) * R;
    planetPH.position.set(x, 0, z);
    if (planetReal) planetReal.position.set(x, 0, z);

    // initialize arc on first frame
    if (arcStartTheta === null) {
      arcStartTheta = theta;
      lastTheta = theta;
      orbitStartSimDays = simDays;
      updateProgressArc(R, arcStartTheta, theta + 1e-6); // tiny stub
    } else {
      // detect wrap (theta decreased → new revolution)
      if (theta < lastTheta) {
        // reset arc for new orbit
        arcStartTheta = theta;
        orbitStartSimDays = simDays;
        updateProgressArc(R, arcStartTheta, theta + 1e-6);
      } else {
        // extend arc
        updateProgressArc(R, arcStartTheta, theta);
      }
      lastTheta = theta;
    }

    // label + HUD text (elapsed days in current orbit)
    const orbitElapsed = simDays - orbitStartSimDays;
    lbl.textContent = `${orbitElapsed.toFixed(2)} d`;
    daysText.textContent = `${orbitElapsed.toFixed(2)} d`;

    // crossfade placeholders -> real; finish blur-down
    if (reveal > 0 && starReal && planetReal){
      reveal = Math.min(1, reveal + 0.03);
      const realOpacity = reveal;
      starReal.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });
      planetReal.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });

      starPH.visible   = (1 - reveal) > 0.02;
      planetPH.visible = (1 - reveal) > 0.02;

      currentBlur = Math.max(0, currentBlur - 0.6);
      applyBlur(currentBlur);

      if (reveal === 1){
        panelEl.classList.add('hidden');
        applyBlur(0);
      }
    }

    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  applyBlur(currentBlur);
  animate(0);

  // -----------------------
  // Resize
  // -----------------------
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    labelRenderer.setSize(innerWidth, innerHeight);
  });

  // -----------------------
  // Keyboard controls: [ slower, ] faster, Space pause
  // -----------------------
  addEventListener('keydown', (e)=>{
    if (e.key === '[') {
      SIM_SPEED_DAYS_PER_SEC = Math.max(0.01, SIM_SPEED_DAYS_PER_SEC / 1.5);
      smallEl.textContent = `Speed: ${SIM_SPEED_DAYS_PER_SEC.toFixed(2)} d/s (slower)`;
    } else if (e.key === ']') {
      SIM_SPEED_DAYS_PER_SEC = Math.min(1e3, SIM_SPEED_DAYS_PER_SEC * 1.5);
      smallEl.textContent = `Speed: ${SIM_SPEED_DAYS_PER_SEC.toFixed(2)} d/s (faster)`;
    } else if (e.code === 'Space') {
      paused = !paused;
      smallEl.textContent = paused ? 'Paused' : `Speed: ${SIM_SPEED_DAYS_PER_SEC.toFixed(2)} d/s`;
    }
  });

  // start progress non-zero so bar isn’t empty on cache
  setProgress(5);
</script>
</body>
</html>
